/*
 * 大名情報型
 */
#pragma once
#pragma pack(1)

#include <windows.h>

#include "大名情報列挙.h"

/*
	大名(22*72)

	0-1	武将INDEX
	2-3	軍団番号
	4-5	居城
	6-7	隠居リスト先頭
	8	家紋
	9	朝廷
	A	敵対大名
	B	友好大名
	C
	D	商人
	E	000A 000B  A評定 B布教
	F	役職 0x01 将軍 0x02 管領 0x04 関東管領 0x08 奥州探題 0x10 西国探題 0x20 九州探題 0x40 羽州探題　⇒Get_大名役職
		複数兼職にはならないようだ
*/
struct 大名情報型
{
    WORD 大名【武将番号】;		/// <summary>大名の武将としての番号</summary>
	WORD 所属軍団【軍団番号】;	/// <summary>軍団 軍団番号</summary>
	WORD 所属居城【城番号】;	/// <summary>居城</summary>
	WORD 隠居武将【武将番号】;	/// <summary>あまり使うことはない。隠居リスト先頭</summary>
	byte 家紋;					/// <summary>家紋番号。0〜159。最後の16個はユーザーが編集した家紋となる。</summary>
    byte 朝廷;					/// <summary>朝廷との親密度</summary>
	byte 敵対大名【大名番号】;	/// <summary>敵対大名。敵対大名が居ない場合は255(=0xFF)。</summary>
	byte 友好大名【大名番号】;	/// <summary>共闘大名。友好大名という名前だが「友好値」とは無関係。共闘大名が居ない場合は255(=0xFF)。</summary>
	byte 御用商人 : 4;			/// <summary>どこの商人か<para>「御用商人::神屋宗湛」〜「御用商人::灰屋紹由」までの値をとる。</para></summary>
	byte _未定義0 : 4;			//
	byte 商人;					/// <summary>商人との新密度</summary>
	byte 布教済:1;				/// <summary>布教 :布教済みか否か</summary>
	byte 商人不在 : 1;			/// <summary>商人が怒ってしまって不在。1なら不在。0なら商売可能。</summary>
	byte _未定義2:2;			/// must 0 他の残り空ビットに過ぎない。勝手に数値入れないこと
	byte 評定済 : 1;			/// <summary>評定 :評定済みかどうか</summary>
	byte _未定義3:3;			/// <summary>must 0 評定の残り空ビットに過ぎない。勝手に数値入れないこと</summary>
	byte _役職;					/// <summary><para>役職。</para><para>0x01 将軍 0x02 管領 0x04 関東管領 0x08 奥州探題 0x10 西国探題 0x20 九州探題 0x40 羽州探題。</para><para>この値を直接使用せず、Get_大名役職などを使用すること。</para></summary>
	byte _未定義4[6];			//
};



namespace 関数 {

	/// <summary>
	/// 現在有効な大名のリストを得る。
	/// <para>「大名全体」に何かをしたり、「選択大名ダイアログ表示()」関数等、「大名一覧を引数に渡す」目的で利用する。</para>
	/// <para>返り値：大名の「配列用」の番号のリストを返す。</para>
	/// </summary>
	/// <param name="ターン大名を含む">FALSEを指定すると、ターンが回っている大名以外のリストとなる。</param>
	/// <returns>大名の「配列用」の番号のリストを返す。</returns>
	番号リスト型 Get_大名番号リスト【配列用】(BOOL ターン大名を含む=TRUE);
}



/*
 */
namespace 関数 {

	/// <summary>
	/// Ａ大名とＢ大名との友好値を得る。
	/// <para>返り値：友好値</para>
	/// </summary>
	/// <param name="大名Ａ番号【配列用】">１人目の大名の「配列用」の番号</param>
	/// <param name="大名Ｂ番号【配列用】">２つ目の大名の「配列用」の番号</param>
	/// <returns>友好値</returns>
	int Get_友好関係(int 大名Ａ番号【配列用】, int 大名Ｂ番号【配列用】);


	/// <summary>
	/// Ａ大名とＢ大名との友好値を設定する。
	/// <para>友好値が92のような中途半端な数だった場合90というように切り捨てられる。</para>
	/// <para>マイナス値は0に、100オーバーは100となる。</para>
	/// </summary>
	/// <param name="大名Ａ番号【配列用】">１人目の大名の「配列用」の番号</param>
	/// <param name="大名Ｂ番号【配列用】">２つ目の大名の「配列用」の番号</param>
	/// <param name="友好値">設定したい友好値
	/// <remarks>
	/// <para>あまり気にする必要はないが、友好関係の値は、決して自由なものではなく、16種類の規定値の中から指定されている。</para>
	/// <para>しかし、それらの中から指定したり比較する、というのはいかにも面倒であったり非直感的なので、</para>
	/// <para>Set_友好関係では、普通に直感的な値にて、0〜100まで自由に設定して、自動的に規定に値へと変換されるという仕組みとした。</para>
	/// <para>例えば友好値として、｢94｣と指定した場合、実際にはそのような友好値(の規定値)は存在し得ない、自動的に90へと(値が小さくなる方向で)変換している。</para>
	/// </remarks>
	/// </param>
	void Set_友好関係(int 大名Ａ番号【配列用】, int 大名Ｂ番号【配列用】, int 友好値);


	/// <summary>
	/// Ａ大名とＢ大名が同盟関係かどうかを得る。
	/// <para>返り値：同盟関係なら真、同盟関係でないなら偽</para>
	/// </summary>
	/// <param name="大名Ａ番号【配列用】">１人目の大名の「配列用」の番号</param>
	/// <param name="大名Ｂ番号【配列用】">２つ目の大名の「配列用」の番号</param>
	/// <returns>同盟関係なら真、同盟関係でないなら偽</returns>
	int Is_同盟関係(int 大名Ａ番号【配列用】, int 大名Ｂ番号【配列用】);


	/// <summary>
	/// Ａ大名とＢ大名が婚姻関係かどうかを得る。
	/// <para>返り値：婚姻関係なら真、婚姻関係でないなら偽</para>
	/// </summary>
	/// <param name="大名Ａ番号【配列用】">１人目の大名の「配列用」の番号</param>
	/// <param name="大名Ｂ番号【配列用】">２つ目の大名の「配列用」の番号</param>
	/// <returns>婚姻関係なら真、婚姻関係でないなら偽</returns>
	int Is_婚姻関係(int 大名Ａ番号【配列用】, int 大名Ｂ番号【配列用】);


	/// <summary>
	/// Ａ大名とＢ大名を同盟状態とする。
	/// </summary>
	/// <param name="大名Ａ番号【配列用】">１人目の大名の「配列用」の番号</param>
	/// <param name="大名Ｂ番号【配列用】">２つ目の大名の「配列用」の番号</param>
	/// <param name="同盟化">TRUEなら同盟化、FALSEなら同盟解除</param>
	void Set_同盟関係(int 大名Ａ番号【配列用】, int 大名Ｂ番号【配列用】, BOOL 同盟化 = TRUE);


	/// <summary>
	/// Ａ大名とＢ大名を婚姻状態とする。
	/// </summary>
	/// <param name="大名Ａ番号【配列用】">１人目の大名の「配列用」の番号</param>
	/// <param name="大名Ｂ番号【配列用】">２つ目の大名の「配列用」の番号</param>
	/// <param name="婚姻化">TRUEなら婚姻化、FALSEなら婚姻解除</param>
	void Set_婚姻関係(int 大名Ａ番号【配列用】, int 大名Ｂ番号【配列用】, BOOL 婚姻化 = TRUE);

}

