/*
 * 城情報型 及び、 城付加情報型
 */
#pragma once
#pragma pack(1)

#include <windows.h>

#include "城情報列挙.h"

using namespace std;

/*
	城情報(33*214)

	[33バイト]

	0-1		軍団所属リストの前
	2-3		リストの後ろ
	4-5		城主
	6-7		浪人先頭
	8-16	城名
	17-18	所属	所属軍団の軍団番号
	19		城郭
	20-21	石高
	22		商業
	23-24	人口-徴兵可
	25		民忠
	26-27	徴兵可
	28		兵質 0-2
	29		ABC0 EFGH
			A 一揆 B 国際港 C 港 E 馬産地 F 鍛冶 G 本城 H 巨城
	30		ABCD EFGH
			C 一揆扇動 G 金山 H 銀山
	31		AAAAAA BB
			A:城称	0x00 城 0x01 御坊 0x02 寺 0x04 御所 0x08 館 0x10 町 0x20 城、それ以外の値=何も付かない
			B:｢絵｣を表示した時の、背景の種類(0=山) (1=林) (2=海) (3=平野)
	32		000A000B A-巨城 B 名前変更
*/
struct 城情報型
{
	WORD 前の城【城番号】;			/// <summary>あまり使うことはない  軍団所属城リスト 前の城</summary>
	WORD 次の城【城番号】;			/// <summary>とくに使うことはない  軍団所属城リスト 後の城</summary>
	WORD 城主【武将番号】;			/// <summary><para>城主の武将番号。</para><para>その城の武将のリンクリストの先頭でもあるため、この番号を直接編集しないこと。</para><para>城主を変更したい場合、Set_城主(...) を利用すること</para></summary>
	WORD _浪人先頭武将【武将番号】;	/// <summary>あまり使うことはない。その城に浪人が居る際の浪人リンクリストの最初の武将番号。</summary>

	char _城名[9];					/// <summary>城名。これを直接使わず、Get_城名(...)を使うこと。</summary>
	WORD 所属軍団【軍団番号】;		/// <summary>所属軍団番号。p軍団情報[ix]のixの値より１つ大きな数。</summary>
	byte 城郭;						/// <summary>城郭</summary>
	WORD 石高;						/// <summary>石高</summary>
	byte 商業;						/// <summary>商業</summary>
	WORD 人口;						/// <summary>人口</summary>
	byte 民忠;						/// <summary>民忠</summary>
	WORD 徴兵可;					/// <summary>徴兵可</summary>

	byte 兵質;						/// <summary><para>兵質 0-2  (悪=0, 普=1, 良=2)</para><para>「兵質::悪」〜「兵質::良」に対応する。</para></summary>
	byte 本城:2;					/// <summary><para>本城 居城 (大名の本城=1, 軍団長の居城=2)。</para><para>「本城::大名、本城::軍団長」に対応する。</para></summary>
	byte 鍛冶:1;					/// <summary>鍛冶</summary>
	byte 馬産地:1;					/// <summary>馬産地</summary>
	byte _未定義3:1;				/// <summary>0</summary>
	byte 港:1;						/// <summary>港</summary>
	byte 国際港:1;					/// <summary>国際港</summary>
	byte _未定義4:1;				
	byte 銀山:1;					/// <summary><para>銀山</para><para>銀山を持っていると、その城の「金山」の評価がＢとなる。</para><para>金山を持っていると、その城の「金山」の評価がＡとなる。</para><para>銀山と金山の両方を持っていると、その城の「金山」の評価がＳとなる。</para><para>両方もっていない場合は、その城の「金山」の評価は×となる。</para></summary>
	byte 金山:1;					/// <summary><para>金山</para><para>銀山を持っていると、その城の「金山」の評価がＢとなる。</para><para>金山を持っていると、その城の「金山」の評価がＡとなる。</para><para>銀山と金山の両方を持っていると、その城の「金山」の評価がＳとなる。</para><para>両方もっていない場合は、その城の「金山」の評価は×となる。</para></summary>
	byte _未定義5:2;				///
	byte 一揆扇動 : 1;				/// <summary>一揆扇動</summary>
	byte _未定義6:3;				///

	byte 城絵背景:2;				/// <summary><para>｢絵｣を表示した時の、背景の種類 城称(0=山) (1=林) (2=海) (3=平野)。</para><para>「城絵背景::山」〜「城絵背景::平野」に対応する。</para></summary>
	byte _城称:6;					/// <summary>ここの情報はGet_城称(...)で得ること。</summary>
	byte _城名変更済:1;				///  <summary><para>城名を変更しているため、必ず「_城名[9]」や「_城称」の方をデータとして参照せよ、というフラグ</para></summary>
	byte _未定義7 : 2;				///  
	byte 巨城:1;					/// <summary>巨城</summary>

	byte _未定義8 :4;				/// <summary>基本０が入っている模様</summary>
};


namespace 関数 {

	/// <summary>
	/// 対象の城名を取得するを取得する。
	/// <para>返り値：対象の城名の文字列。最大で全角４文字。(8バイト)</para>
	/// </summary>
	/// <param name="城番号【配列用】">対象の城の「配列用」の番号</param>
	/// <returns>対象の城名の文字列。最大で全角４文字。(8バイト)</returns>
	string Get_城名( int 城番号【配列用】);


	/// <summary>
	/// 対象の城の名前を設定する。
	/// </summary>
	/// <param name="城番号【配列用】">対象の城の「配列用」の番号</param>
	/// <param name="城名】">対象の城の名前。最大で全角４文字。(8バイト)</param>
	void Set_城名( int 城番号【配列用】, string 城名 );


	/// <summary>
	/// 「城・御所・館」といったような、城名に付ける城称の文字列を得る。
	/// <para>返り値：対象の城の城称の文字列</para>
	/// </summary>
	/// <param name="城番号【配列用】">対象の城の「配列用」の番号</param>
	/// <returns>対象の城の城称の文字列</returns>
	string Get_城称(int 城番号【配列用】);


	/// <summary>
	/// 「城・御所・館」といったような、城名に付ける城称の文字列を設定する。
	/// </summary>
	/// <param name="城番号【配列用】">対象の城の「配列用」の番号</param>
	/// <param name="城称">"城"、"御坊"、"寺"、"御所"、"館"、"町" のいずれかの指定する。"町"の代わりに""でもよい。</param>
	/// <returns>対象の城の城称の文字列</returns>
	void Set_城称(int 城番号【配列用】, string 城称);

	/// <summary>
	/// 対象の城名に対応する城番号「配列用」を取得する。
	/// <para>返り値：対象の城名に対応する城番号「配列用」。対象の城が存在しない時には0xFFFFが返ってくる。</para>
	/// </summary>
	/// <param name="城名">対象の城名の文字列。
	/// <para><para>｢◎◎城」や「▲▲寺」のうち「◎◎」や「▲▲」に相当する文字列を指定すること。</para></para>
	/// </param>
	/// <returns>対象の城名に対応する城番号「配列用」。対象の城が存在しない時には0xFFFFが返ってくる。</returns>
	int Get_城番号【配列用】(string 城名);


	/// <summary>
	/// 指定の軍団が所持している城の数を得る。
	/// <para>返り値：指定軍団が所持している城の数。指定軍団が存在しない場合などは0が返ってくる。</para>
	/// </summary>
	/// <param name="軍団番号【配列用】">対象の軍団の「配列用」の番号</param>
	/// <returns>指定軍団が所持している城の数。指定軍団が存在しない場合などは0が返ってくる。</returns>
	int Get_軍団所持城数(int 軍団番号【配列用】);


	/// <summary>
	/// 指定の軍団が所持している城の「配列用」番号のリストを得る。
	/// <para>返り値：指定軍団が所持している城の「配列用」番号のリスト。指定軍団が存在しない場合などは空のリストが返ってくる。</para>
	/// </summary>
	/// <param name="軍団番号【配列用】">対象の軍団の「配列用」の番号</param>
	/// <returns>指定軍団が所持している城の「配列用」番号のリスト。指定軍団が存在しない場合などは空のリストが返ってくる。</returns>
	番号リスト型 Get_軍団所持城番号リスト【配列用】(int 軍団番号【配列用】);


	/// <summary>
	/// 指定の大名が所持している城の数を得る。
	/// <para>返り値：指定大名が所持している城の数。指定大名が存在しない場合などは0が返ってくる。</para>
	/// </summary>
	/// <param name="大名番号【配列用】">対象の大名の「配列用」の番号</param>
	/// <returns>指定大名が所持している城の数。指定大名が存在しない場合などは0が返ってくる。</returns>
	int Get_大名所持城数(int 大名番号【配列用】);


	/// <summary>
	/// 指定の大名が所持している城の「配列用」番号のリストを得る。
	/// <para>返り値：指定大名が所持している城の「配列用」番号のリスト。指定大名が存在しない場合などは空のリストが返ってくる。</para>
	/// </summary>
	/// <param name="大名番号【配列用】">対象の大名の「配列用」の番号</param>
	/// <returns>指定大名が所持している城の「配列用」番号のリスト。指定大名が存在しない場合などは空のリストが返ってくる。</returns>
	番号リスト型 Get_大名所持城番号リスト【配列用】(int 大名番号【配列用】);
}


/*
	城の位置情報など(8*214)

	[8バイト]

	0	地域名
	1	0
	2	石高最大値/10
	3	商業最大値
	4	Xセル座標(マップで見えてるのとは異なる区切り方 50個で区切られている)
	5	Yセル座標(上と同じで、マップで見えているのとは異なる区切り方12個程度で区切られている)
	6	X_offset
	7	Y_offset
*/
struct 城付加情報型
{
    byte 所属地域【地域番号】;	/// <summary>対象の城が属している地域。地域情報型を参照のこと。</summary>
	byte _未定義1;				/// <summary>must 0</summary>
	byte 最大石高÷10;			/// <summary>最大石高÷10。画面上ではこの値の10倍の値が表示される。</summary>
	byte 最大商業値;			/// <summary>最大商業</summary>
	byte _Ｘ情報;				/// <summary><para>やや不透明。特に利用することはない。</para><para>後述のＸ位置と相関的な値。</para></summary>
	byte _Ｙ情報;				/// <summary><para>やや不透明。特に利用することはない。</para><para>後述のＹ位置と相関的な値。</para></summary>
	byte Ｘ位置;				/// <summary><para>城のＸ位置。</para><para>Set_城位置(...)で指定する値と同じ。グリッドマップを導入すればよくわかる。</para><para>グリッド内のＸ幅は５（うち４つが使え、１つは境界線上）</para></summary>
	byte Ｙ位置;				/// <summary><para>城のＹ位置。</para><para>Set_城位置(...)で指定する値と同じ。グリッドマップを導入すればよくわかる。</para><para>グリッド内のＹ幅は３．</para></summary>
};

namespace 関数 {

	/// <summary>
	/// 城の位置を移動する。
	/// <para>「同じ城グリッド内」で移動すること。グリッドをはみ出すと、城をクリックしても反応しなくなってしまう。</para>
	/// </summary>
	/// <param name="城番号【配列用】">対象の城の「配列用」の番号</param>
	/// <param name="Ｘ位置">城のＸ位置。</param>
	/// <param name="Ｙ位置">城のＹ位置。</param>
	void Set_城位置(int 城番号【配列用】, int Ｘ位置, int Ｙ位置);
}



/*
 以下、メインマップのグリッド線で区切られた城グリッドの位置の計算
 */

/// <summary>
/// <para>メインマップのグリッド用の構造体。</para>
/// <para>Get_城グリッド位置(int 城番号【配列用】)関数の返り値として得ることが出来る。</para>
/// </summary>
struct 城グリッド位置型 {
	int Ｘ; // Ｘ方向のグリッド番目。０始まり。画面の左端が０。
	int Ｙ; // Ｙ方向のグリッド番目。０始まり。画面の上端が０。
	城グリッド位置型(int _x,int _y);
	城グリッド位置型() : Ｘ(0),Ｙ(0) {}

	WORD 北西【城番号】; // 存在しない時は、0xFFFF;
	WORD 北【城番号】;   // 存在しない時は、0xFFFF;
	WORD 北東【城番号】; // 存在しない時は、0xFFFF;
	WORD 西【城番号】;   // 存在しない時は、0xFFFF;
	WORD 東【城番号】;   // 存在しない時は、0xFFFF;
	WORD 南西【城番号】; // 存在しない時は、0xFFFF;
	WORD 南【城番号】;   // 存在しない時は、0xFFFF;
	WORD 南東【城番号】; // 存在しない時は、0xFFFF;
};

/// <summary>
/// 「２点の城グリッド位置型」の差分を意味する方向ベクトル。
/// </summary>
struct 城グリッドベクトル型 {
	int Ｘ;
	int Ｙ;
	城グリッドベクトル型(int Ｘ成分, int Ｙ成分) : Ｘ(Ｘ成分),Ｙ(Ｙ成分) {}
	城グリッドベクトル型() : Ｘ(0),Ｙ(0) {}
};

namespace 関数 {

	/// <summary>
	/// 対象の城の画面の「グリッドとしての」位置を得る。
	/// <para>左上グリッドが0,0。MapDataObgkMod(戦場グリッドマップ)を導入していると、</para>
	/// <para>グリッドがはっきりと目で見えるのでわかりやすい</para>
	/// <para>画面上では、上が０で画面の下にいくほど数値が増える。</para>
	/// <para>(※１つのグリッドには、１つの城しかない。)</para>
	/// <para>返り値：対象の城の「城グリッド位置型」としての情報。</para>
	/// </summary>
	/// <param name="城番号【配列用】">対象の城の「配列用」の番号</param>
	/// <returns>対象の城の「城グリッド位置型」としての情報。</returns>
	城グリッド位置型 Get_城グリッド位置(int 城番号【配列用】);


	/// <summary>
	/// 城グリッド座標同志の減算。座標Ａ→座標Ｂの差である方向ベクトル。
	/// </summary>
	城グリッドベクトル型 operator-(城グリッド位置型 &p1, 城グリッド位置型 &p2);


	/// <summary>
	/// 城Ａと城Ｂが隣接しているかどうか。(道がつながっているかどうかは考慮しない)
	/// <para>返り値：隣接していたらtrue、隣接していなければfalse</para>
	/// </summary>
	/// <param name="城Ａ番号【配列用】">対象の城Ａの「配列用」の番号</param>
	/// <param name="城Ｂ番号【配列用】">対象の城Ｂの「配列用」の番号</param>
	/// <returns>隣接していたらtrue、隣接していなければfalse</returns>
	bool Is_隣接城(int 城Ａ番号【配列用】, int 城Ｂ番号【配列用】);


	/// <summary>
	/// 城Ａと城Ｂが隣接しているかどうか。(道がつながっているかどうかは考慮しない)
	/// <para>返り値：隣接していたらtrue、隣接していなければfalse</para>
	/// </summary>
	/// <param name="位置１">対象の城Ａの城グリッド位置型の値</param>
	/// <param name="位置２">対象の城Ｂの城グリッド位置型の値</param>
	/// <returns>隣接していたらtrue、隣接していなければfalse</returns>
	bool Is_隣接城(城グリッド位置型 &位置１, 城グリッド位置型 &位置２);


	/// <summary>
	/// 対象の城を中心に、「経路(道)」が繋がっている周辺の城番号のリストを得る。
	/// <para>返り値：対象城の「周辺の隣接城」でかつ「道が繋がっている城」の「城番号『配列用』」のリスト。</para>
	/// </summary>
	/// <param name="城番号【配列用】">対象の城の「配列用」の番号</param>
	/// <returns>対象城の「周辺の隣接城」でかつ「道が繋がっている城」の「城番号『配列用』」のリスト。</returns>
	番号リスト型 Get_経路連結の隣接城番号リスト【配列用】(int 城番号【配列用】);


	/*
	ここから下は経路探索関連。
	*/

	// 
	/// <summary>
	/// 城経路のグラフを現在実行中の道連結や城位置の情報を元に再構築する。
	/// </summary>
	void Set_城経路グラフ初期化();


	/// <summary>
	/// <para>城経路のグラフ関連の計算において、対象の城は「経路計算」から除外する。</para>
	/// <para>これによって、「Get_経路上の城番号リスト【配列用】(...)」の関数で経路探索の対象範囲をコントロール出来る。</para>
	/// </summary>
	/// <param name="城番号【配列用】">対象の城の「配列用」の番号</param>
	void Set_城経路グラフから城削除(int 城番号【配列用】);


	/// <summary>
	/// <para>開始点の城Ａ→目的点の城Ｂまで、理想的に道経路でつないだ際、辿ることとなる経路上の城一覧を得る。</para>
	/// <para>返り値：対象城の「周辺の隣接城」でかつ「道が繋がっている城」の「城番号『配列用』」のリスト。</para>
	/// </summary>
	/// <param name="開始城番号【配列用】">開始(起点)ポイントとなる城の「配列用」の番号</param>
	/// <param name="目的城番号【配列用】">目的(終点)ポイントとなる城の「配列用」の番号</param>
	/// <returns>対象城の「周辺の隣接城」でかつ「道が繋がっている城」の「城番号『配列用』」のリスト。</returns>
	番号リスト型 Get_経路上の城番号リスト【配列用】(int 開始城番号【配列用】, int 目的城番号【配列用】);
}





/// <summary>
/// 「戦国名城物語型＆ カスタム::On_戦国名城物語要求時(int 城番号) 」メソッドの返り値の型
/// </summary>
struct 戦国名城物語型 {

public:
	string _ラベル;
	string _詳細;

public:
	/// <summary>
	/// 戦国名城物語を設定する。
	/// </summary>
	/// <param name="ラベル">戦国名城物語時に表示される、名前。36バイトまで。全角だと18文字。</param>
	/// <param name="詳細">戦国名城物語時に表示される、詳細な名城物語。全角だと18文字×４行。</param>
	inline  戦国名城物語型(string ラベル, string 詳細) {
		_ラベル = ラベル;
		_詳細 = 詳細;
	};

	// NULLリターンに対応するため。
	inline  戦国名城物語型(int iDefault) {}
};
#define  戦国名城物語型＆	 戦国名城物語型
