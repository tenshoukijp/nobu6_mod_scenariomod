#include "２Ｄ位置情報型.h"

#include <windows.h>

//比較演算子
bool ２Ｄ位置型::operator==(const ２Ｄ位置型& v ) const{
    return (Ｘ == v.Ｘ) && (Ｙ == v.Ｙ);
}
bool ２Ｄ位置型::operator!=(const ２Ｄ位置型& v ) const{
    return !(*this == v);
}
//代入演算子
２Ｄ位置型& ２Ｄ位置型::operator=(const ２Ｄ位置型& v){
	this->Ｘ=v.Ｘ;
	this->Ｙ=v.Ｙ;
	return *this;
}

//*----------------------メンバ関数の実装--------------------------*//
２Ｄベクトル型::２Ｄベクトル型(){ Ｘ = Ｙ = 0; }
２Ｄベクトル型::２Ｄベクトル型(double Ｘ成分, double Ｙ成分){
	this->Ｘ=Ｘ成分;
	this->Ｙ=Ｙ成分;
}
２Ｄベクトル型::２Ｄベクトル型(２Ｄ位置型 pos){
	this->Ｘ=pos.Ｘ;
	this->Ｙ=pos.Ｙ;
}

//代入演算子
２Ｄベクトル型& ２Ｄベクトル型::operator=(const ２Ｄベクトル型& v){
	this->Ｘ=v.Ｘ;
	this->Ｙ=v.Ｙ;
	return *this;
}
//単項演算子
２Ｄベクトル型& ２Ｄベクトル型::operator+=(const ２Ｄベクトル型& v){
	 this->Ｘ += v.Ｘ;
	 this->Ｙ += v.Ｙ;
	 return *this;
}
２Ｄベクトル型& ２Ｄベクトル型::operator-=(const ２Ｄベクトル型& v){
	 this->Ｘ -= v.Ｘ;
	 this->Ｙ -= v.Ｙ;
	 return *this;
}
２Ｄベクトル型& ２Ｄベクトル型::operator*=(double k){
	 this->Ｘ *= k;
	 this->Ｙ *= k;
	 return *this;
}
２Ｄベクトル型& ２Ｄベクトル型::operator/=(double k){
	this->Ｘ /= k;
	this->Ｙ /= k;
	return *this;
}
２Ｄベクトル型 ２Ｄベクトル型::operator+()const{		//+２Ｄベクトル型
	return *this;
}
２Ｄベクトル型 ２Ｄベクトル型::operator-()const{		//-２Ｄベクトル型
	return ２Ｄベクトル型(-Ｘ,-Ｙ);
}
//添え字演算子
double& ２Ｄベクトル型::operator[](int i){
	if(i == 0){
		return Ｘ;
	}
	else if(i == 1){
		return Ｙ;
	}
	else{
		return Ｘ;
	}
}
//比較演算子
bool ２Ｄベクトル型::operator==(const ２Ｄベクトル型& v ) const {
    return (Ｘ == v.Ｘ) && (Ｙ == v.Ｙ);
}
bool ２Ｄベクトル型::operator!=(const ２Ｄベクトル型& v ) const {
    return !(*this == v);
}
//べクトルの長さ
double ２Ｄベクトル型::長さ() const {
	return pow((double)(Ｘ*Ｘ+Ｙ*Ｙ),(double)0.5f);
}
//正規化(単位ベクトル化)
void ２Ｄベクトル型::正規化(){
	if ( 長さ() == 0 ) {
		MessageBox(NULL, "長さが０のベクトル(=方向が無いベクトル)を単位ベクトル化しようとしました。無限０除算でエラーとなります。","長さが０のベクトル(=方向が無いベクトル)を単位ベクトル化しようとしました。無限０除算でエラーとなります。", NULL);
	}

	*this /= 長さ();
}
//*----------------------グローバル関数の実装--------------------------*//
//二項演算子の定義
//２Ｄベクトル型+２Ｄベクトル型
２Ｄベクトル型 operator+(const ２Ｄベクトル型& u,const ２Ｄベクトル型& v){
	２Ｄベクトル型 w;
	w.Ｘ=u.Ｘ+v.Ｘ;
	w.Ｙ=u.Ｙ+v.Ｙ;
	return w;
}
//２Ｄベクトル型-２Ｄベクトル型
２Ｄベクトル型 operator-(const ２Ｄベクトル型& u,const ２Ｄベクトル型& v){
	２Ｄベクトル型 w;
	w.Ｘ=u.Ｘ-v.Ｘ;
	w.Ｙ=u.Ｙ-v.Ｙ;
	return w;
}
//double*２Ｄベクトル型
２Ｄベクトル型 operator*(double k,const  ２Ｄベクトル型& v){
	return ２Ｄベクトル型(k*v.Ｘ,k*v.Ｙ);
}
//２Ｄベクトル型*double
２Ｄベクトル型 operator*(const ２Ｄベクトル型& v,double k){
	return ２Ｄベクトル型(v.Ｘ*k,v.Ｙ*k);
}
//２Ｄベクトル型/double
２Ｄベクトル型 operator/(const ２Ｄベクトル型& v,double k){
	return ２Ｄベクトル型(v.Ｘ/k,v.Ｙ/k);
}
//内積 ２Ｄベクトル型*２Ｄベクトル型
double operator*(const ２Ｄベクトル型& u,const ２Ｄベクトル型& v){
	return u.Ｘ*v.Ｘ+u.Ｙ*v.Ｙ;
}

//外積 ２Ｄベクトル型%２Ｄベクトル型
double operator%(const ２Ｄベクトル型& u,const ２Ｄベクトル型& v){
	２Ｄベクトル型 w;
	return u.Ｘ*v.Ｙ-u.Ｙ*v.Ｘ;
}

//２つのベクトルのなす角
double 角度(const ２Ｄベクトル型& u,const ２Ｄベクトル型& v){

	if (u.長さ() == 0 || v.長さ() == 0) {
		return 0;
	}

	double cos =u*v/(u.長さ()*v.長さ());
	return double(acos(cos)/M_PI*180);
}

//２点間座標の差
２Ｄベクトル型 operator-(２Ｄ位置型 &p1, ２Ｄ位置型 &p2) {
	２Ｄベクトル型 v;
	v.Ｘ = p1.Ｘ - p2.Ｘ;
	v.Ｙ = p1.Ｙ - p2.Ｙ;
	return v;
}


// ベクトルを文字列化するが、東西南北系（８方位）で文字列化。
string Get_８方位文字列(２Ｄベクトル型 v) {

	if ( v.長さ() == 0 ) {
		return "無方位";
	}

	double 内積の最大 = -1; // 真逆からのスタート
	string 方向名 = "";

	//　８つの方向の「単位ベクトル」を用意して、「最寄り城からのベクトル」との内積が最大のものをい採用する。
	// 単位ベクトル同志の内積が１に近いほど（すなわち大きいほど）ということは、２つのベクトルの方向は同じ方向である。
	// 逆に言えば真逆であるほど最少（すなわち-1)に近づく。
	２Ｄベクトル型 i(0,-1); // 北と比較
	if ( i * v > 内積の最大) {
		内積の最大 = i * v;
		方向名 = "北";
	}

	i = ２Ｄベクトル型(0,1); // 南と比較
	if ( i * v > 内積の最大) {
		内積の最大 = i * v;
		方向名 = "南";
	}

	i = ２Ｄベクトル型(1,0); // 東と比較
	if ( i * v > 内積の最大) {
		内積の最大 = i * v;
		方向名 = "東";
	}

	i = ２Ｄベクトル型(-1,0); // 西と比較
	if ( i * v > 内積の最大) {
		内積の最大 = i * v;
		方向名 = "西";
	}

	i = ２Ｄベクトル型(1,-1); // 東北と比較
	i.正規化(); // 単位ベクトル化
	if ( i * v > 内積の最大) {
		内積の最大 = i * v;
		方向名 = "北東";
	}

	i = ２Ｄベクトル型(-1,-1); // 西北と比較
	i.正規化(); // 単位ベクトル化
	if ( i * v > 内積の最大) {
		内積の最大 = i * v;
		方向名 = "北西";
	}

	i = ２Ｄベクトル型(1,1); // 東南と比較
	i.正規化(); // 単位ベクトル化
	if ( i * v > 内積の最大) {
		内積の最大 = i * v;
		方向名 = "南東";
	}

	i = ２Ｄベクトル型(-1,1); // 西南と比較
	i.正規化(); // 単位ベクトル化
	if ( i * v > 内積の最大) {
		内積の最大 = i * v;
		方向名 = "南西";
	}

	return 方向名;
}



// ベクトルを文字列化するが、東西南北系（４方位）で文字列化。
string Get_４方位文字列(２Ｄベクトル型 v) {

	if ( v.長さ() == 0 ) {
		return "無方位";
	}

	double 内積の最大 = -1; // 真逆からのスタート
	string 方向名 = "";

	//　４つの方向の「単位ベクトル」を用意して、「最寄り城からのベクトル」との内積が最大のものをい採用する。
	// 単位ベクトル同志の内積が１に近いほど（すなわち大きいほど）ということは、２つのベクトルの方向は同じ方向である。
	// 逆に言えば真逆であるほど最少（すなわち-1)に近づく。
	２Ｄベクトル型 i(0,-1); // 北と比較
	if ( i * v > 内積の最大) {
		内積の最大 = i * v;
		方向名 = "北";
	}

	i = ２Ｄベクトル型(0,1); // 南と比較
	if ( i * v > 内積の最大) {
		内積の最大 = i * v;
		方向名 = "南";
	}

	i = ２Ｄベクトル型(1,0); // 東と比較
	if ( i * v > 内積の最大) {
		内積の最大 = i * v;
		方向名 = "東";
	}

	i = ２Ｄベクトル型(-1,0); // 西と比較
	if ( i * v > 内積の最大) {
		内積の最大 = i * v;
		方向名 = "西";
	}

	return 方向名;
}
