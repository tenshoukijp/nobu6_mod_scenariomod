#include <cassert>
#include "ゲームデータ構造.h"




namespace 関数 {

番号リスト型 Get_大名番号リスト【配列用】(BOOL ターン大名を含む) {
	番号リスト型 list;
	for ( int iDaimyoID=0; iDaimyoID < 最大数::大名情報::配列数; iDaimyoID++ ) {
		// ターン大名は含まない
		if ( !ターン大名を含む ) {
			// ターン大名ならパス
			if ( iDaimyoID == pターン情報.現在のターン【大名番号】-1 ) {
				continue;
			}
		}

		int iBushouID = p大名情報[iDaimyoID].大名【武将番号】 - 1;
		if ( 0 <= iBushouID && iBushouID < 最大数::武将情報::配列数 ) {
			list.push_back(iDaimyoID);
		}
	}
	return list;
}

}








//------------------有効関係


// Ａ大名(０始まりでの配列用指定)とＢ大名との同盟関係）
// 004CF213  05 55 55 55 95    とあるのは、004CF213 [0 5 5 5 5 5 5 5 9 5] というように1番目、2番目、3番目の相手との友好値(友好値配列のindex)…という感じとなる。  


// 下のGet_友好関係内部で求まる値は、この配列のINDEXであるため、これを使って実際の値に直す。
int 友好値配列[] = {0, 10, 20, 30, 40, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 0xFFFF}; // 0xFFFFは番兵のために付け足したもの






byte* _Get_友好関係ポインタ(int& 大名Ａ番号【配列用】, int& 大名Ｂ番号【配列用】) {

	// 範囲チェック
	if ( 0 <= 大名Ａ番号【配列用】 && 大名Ａ番号【配列用】 < 最大数::大名情報::配列数 ) {
	} else {
		デバッグ出力("指定の大名Ａ番号【配列用】は範囲外");
		return NULL;
	}
	if ( 0 <= 大名Ｂ番号【配列用】 && 大名Ｂ番号【配列用】 < 最大数::大名情報::配列数 ) {
	} else {
		デバッグ出力("指定の大名Ｂ番号【配列用】は範囲外");
		return NULL;
	}

	// 大名Ａと大名Ｂで、大名Ａの方が値が大きい場合、入れ替える。
	// なぜなら友好関係の値は、大名Ａが小さい方の組み合わせテーブルに入っていて、大名Ａが大きい方の組み合わせテーブルには婚姻や同盟の値が入っているから。
	if (大名Ａ番号【配列用】 > 大名Ｂ番号【配列用】 ) {
		// ２つ入れ替え
		大名Ａ番号【配列用】 ^= 大名Ｂ番号【配列用】;
		大名Ｂ番号【配列用】 ^= 大名Ａ番号【配列用】;
		大名Ａ番号【配列用】 ^= 大名Ｂ番号【配列用】;
	}

	byte *p = (byte *)情報メモリアドレス::同盟情報;
	
	// 以下2人の大名ＩＤより、同盟関係値が入っているメモリのアドレスを求める
	p += 大名Ａ番号【配列用】 * ( 最大数::大名情報::配列数 / 2 );	// もしも１つのＡ大名あたり、Ｂ大名への友好値が１バイトで表現されていれば、
																	// ７２大名いるので、７２バイトで表現される。
																	// ところが実際には、4ビットで表現されるので、
																	// １つの大名にぶら下がる構造体データとしては、半分の３６バイトである。

	p += 大名Ｂ番号【配列用】 / 2;									// 上と同じ理由となる。１つの大名の(友好関係構造体)の中でも
																	// １つの相手大名との同盟値に使われているのは半バイト。
																	// よってポインタの位置としては、/2 しておき、偶数か奇数かで、後で演算を振り分ける。

	return p;
}


namespace 関数 {



int Get_友好関係(int 大名Ａ番号【配列用】, int 大名Ｂ番号【配列用】) {

	// 該当の友好関係情報が存在するアドレスを得る。ＡとＢは値が交換されるかもしれない。注意。
	byte *p = _Get_友好関係ポインタ( 大名Ａ番号【配列用】, 大名Ｂ番号【配列用】 );
	if (!p) return 0;

	// アドレスは求まったが、１つのアドレスの1バイト内には、２つの大名が入っている。
	// 大名番号が偶数なら上位桁、偶数なら下位桁である。
	int i友好値IX = 0;
	// 相手大名が偶数だ
	if ( 大名Ｂ番号【配列用】 % 2==0 ) {					 // 偶数であれば、上半分のビットとの＆結果[0 5] のうち[0]を返す
		i友好値IX = (*p) >> 4;

	// 相手大名が奇数だ										 // 奇数であれば、下半分のビットとの＆結果[0 5] のうち[5]を返す
	} else {
		i友好値IX = 0x0F & (*p);
	}

	return 友好値配列[i友好値IX];
}

// 友好関係値をセットする。
void Set_友好関係(int 大名Ａ番号【配列用】, int 大名Ｂ番号【配列用】, int 友好値) {

	// 該当の友好関係情報が存在するアドレスを得る。ＡとＢは値が交換されるかもしれない。注意。
	byte *p = _Get_友好関係ポインタ( 大名Ａ番号【配列用】, 大名Ｂ番号【配列用】 );
	if (!p) return;


	// 負数はヤヴァイので友好関係値として０を指定したものとする。100オーバーも100にしとく。
	if ( 友好値 < 0 )	{ 友好値 = 0;	}
	if ( 友好値 > 100 ) { 友好値 = 100; }

	int i友好値IX = 0;
	// セットしたい友好関係値と、友好関係値の配列を比較して、もっとも近い切捨て値のindexを求める。
	// 例えば友好関係値として53というように指定されても、そのような値には出来ないので、50とするわけだ。
	// そして50は、友好値配列のindex==5に存在する。この5のような値を求めたい。
	// なぜなら、天翔記では、｢5｣という値でメモリ上に格納されているし、格納するべきだから。
	for ( int i=0; i < sizeof(友好値配列)/sizeof(友好値配列[0]); i++) {
		if ( 友好値 < 友好値配列[i] ) {

			i友好値IX = i-1;	// 値が超えたので、１つ前のindexにしとく。

			if ( i友好値IX < 0 ) { i友好値IX = 0; }  // 理論上ありえないが、何足すかわからんので一応。
			break;
		}
	}

	// アドレスは求まったが、１つのアドレスの1バイト内には、２つの大名が入っている。
	// 大名番号が偶数なら上位桁、偶数なら下位桁である。
	// 相手大名が偶数だ
	if ( 大名Ｂ番号【配列用】 % 2==0 ) {					 // 偶数であれば、上半分のビットとの＆結果[0 5] のうち[0]を返す
		i友好値IX = i友好値IX << 4;
		// 上位バイトはi友好値IXをシフトしたものを、下位バイトは下位バイトの部分だけ抽出で
		*p = i友好値IX | (0x0F & (*p));

	// 相手大名が奇数だ										 // 奇数であれば、下半分のビットとの＆結果[0 5] のうち[5]を返す
	} else {
		// 上位バイトはそのまま採用で、下位バイトは、i友好値IXそのままで。
		*p = (0xF0 & (*p)) | i友好値IX;
	}
}


} // namespace





byte* _Get_婚姻同盟関係ポインタ(int& 大名Ａ番号【配列用】, int& 大名Ｂ番号【配列用】) {

	// 範囲チェック
	if ( 0 <= 大名Ａ番号【配列用】 && 大名Ａ番号【配列用】 < 最大数::大名情報::配列数 ) {
	} else {
		デバッグ出力("指定の大名Ａ番号【配列用】は範囲外");
		return NULL;
	}
	if ( 0 <= 大名Ｂ番号【配列用】 && 大名Ｂ番号【配列用】 < 最大数::大名情報::配列数 ) {
	} else {
		デバッグ出力("指定の大名Ｂ番号【配列用】は範囲外");
		return NULL;
	}

	// 大名Ａと大名Ｂで、大名Ａの方が値が小さい場合、入れ替える。
	// なぜなら同盟関係の値は、大名Ａが大きい方の組み合わせテーブルに入っているから。
	if (大名Ａ番号【配列用】 < 大名Ｂ番号【配列用】 ) {
		// ２つ入れ替え
		大名Ａ番号【配列用】 ^= 大名Ｂ番号【配列用】;
		大名Ｂ番号【配列用】 ^= 大名Ａ番号【配列用】;
		大名Ａ番号【配列用】 ^= 大名Ｂ番号【配列用】;
	}


	byte *p = (byte *)情報メモリアドレス::同盟情報;
	
	// 以下2人の大名ＩＤより、同盟関係値が入っているメモリのアドレスを求める
	p += 大名Ａ番号【配列用】 * ( 最大数::大名情報::配列数 / 2 );	 // もしも１つのＡ大名あたり、Ｂ大名への友好値が１バイトで表現されていれば、
																	 // ７２大名いるので、７２バイトで表現される。
																	 // ところが実際には、4ビットで表現されるので、
																	 // １つの大名にぶら下がる構造体データとしては、半分の３６バイトである。

	p += 大名Ｂ番号【配列用】 / 2;									 // 上と同じ理由となる。１つの大名の(友好関係構造体)の中でも
																	 // １つの相手大名との同盟値に使われているのは半バイト。
																	 // よってポインタの位置としては、/2 しておき、偶数か奇数かで、後で演算を振り分ける。
	return p;
}



namespace 関数 {


int Is_同盟関係(int 大名Ａ番号【配列用】, int 大名Ｂ番号【配列用】) {

	// 該当の同盟関係情報が存在するアドレスを得る。ＡとＢは値が交換されるかもしれない。注意。
	byte *p = _Get_婚姻同盟関係ポインタ( 大名Ａ番号【配列用】, 大名Ｂ番号【配列用】 );
	if (!p) return 0;

	// アドレスは求まったが、１つのアドレスの1バイト内には、２つの大名が入っている。
	// 大名番号が偶数なら上位桁、偶数なら下位桁である。
	// 相手大名が偶数だ
	if ( 大名Ｂ番号【配列用】 % 2==0 ) {					 // 偶数であれば、上半分のビット
		return 0x10 & (*p);
	// 相手大名が奇数だ										 // 奇数であれば、下半分のビット
	} else {
		return 0x01 & (*p);
	}
}
int Is_婚姻関係(int 大名Ａ番号【配列用】, int 大名Ｂ番号【配列用】) {

	// 該当の婚姻関係情報が存在するアドレスを得る(同盟と同じ場所)。ＡとＢは値が交換されるかもしれない。注意。
	byte *p = _Get_婚姻同盟関係ポインタ( 大名Ａ番号【配列用】, 大名Ｂ番号【配列用】 );
	if (!p) return 0;

	// アドレスは求まったが、１つのアドレスの1バイト内には、２つの大名が入っている。
	// 大名番号が偶数なら上位桁、偶数なら下位桁である。

	if ( 大名Ｂ番号【配列用】 % 2==0 ) {					 // 偶数であれば、上半分のビット
		return (0x20 & (*p)) > 0;							 // ２との比較では間違うかもしれないので、一応BOOLっぽくしておく。
	// 相手大名が奇数だ										 // 奇数であれば、下半分のビット
	} else {
		return (0x02 & (*p)) > 0;							 // ２との比較では間違うかもしれないので、一応BOOLっぽくしておく。
	}
}

void Set_同盟関係(int 大名Ａ番号【配列用】, int 大名Ｂ番号【配列用】, BOOL 同盟化) {

	// 該当の同盟関係情報が存在するアドレスを得る。ＡとＢは値が交換されるかもしれない。注意。
	byte *p = _Get_婚姻同盟関係ポインタ( 大名Ａ番号【配列用】, 大名Ｂ番号【配列用】 );
	if (!p) return;
	
	// アドレスは求まったが、１つのアドレスの1バイト内には、２つの大名が入っている。
	// 大名番号が偶数なら上位桁、偶数なら下位桁である。
	// 相手大名が偶数だ
	if ( 大名Ｂ番号【配列用】 % 2==0 ) {					 // 偶数であれば、上半分のビット
		if (同盟化) {
			*p = *p | 0x10;
		}
		else {
			*p = *p & 0xEF;
		}
	// 相手大名が奇数だ										 // 奇数であれば、下半分のビット
	} else {
		if (同盟化) {
			*p = *p | 0x01;
		}
		else {
			*p = *p & 0x0E;
		}
	}
}


void Set_婚姻関係(int 大名Ａ番号【配列用】, int 大名Ｂ番号【配列用】, BOOL 婚姻化) {

	// 該当の婚姻関係情報が存在するアドレスを得る(同盟と同じ場所)。ＡとＢは値が交換されるかもしれない。注意。
	byte *p = _Get_婚姻同盟関係ポインタ( 大名Ａ番号【配列用】, 大名Ｂ番号【配列用】 );
	if (!p) return;
	
	// アドレスは求まったが、１つのアドレスの1バイト内には、２つの大名が入っている。
	// 大名番号が偶数なら上位桁、偶数なら下位桁である。
	// 相手大名が偶数だ
	if ( 大名Ｂ番号【配列用】 % 2==0 ) {					 // 偶数であれば、上半分のビット
		if (婚姻化) {
			*p = *p | 0x20;
		}
		else {
			*p = *p & 0xEF;
		}
	// 相手大名が奇数だ										 // 奇数であれば、下半分のビット
	} else {
		if (婚姻化) {
			*p = *p | 0x02;
		}
		else {
			*p = *p & 0x0E;
		}
	}
}



} // namespace